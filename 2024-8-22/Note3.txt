Part2 Homework从20开始
本部分复习内容：数组、基础排序、类和对象、方法、递归、各种面向对象知识；

1.数组
double[] a = {a, b, c};
int a[] = {1, 2, 3};
a.length
double b[] = new double[5];

#Homework20 用数组和for循环输出A-Z的26个字母
#Homework21 用数组求最大值

数组拷贝 用的是for循环
#Homework22 数组反转

数组扩容
要求实现动态的给数组添加元素，实现对数组扩容
Homework23 进一步修改 用户决定是否继续添加 如果需要则继续

#Homework24 数组缩减

2.排序
手写冒泡排序
#Homework25

java中的查找 两种 一种是顺序查找 一种是二分法查找
#Homework26 给一个数组 手写顺序查找
#Homework27 手写二分查找算法

3.多维数组
int[][] arr = {{0, 0, 0, 1}, {1, 2, 3, 4, 5}, {}};
arr[0].length
#Homework28 求二维数组中每个数组的的和，并分别输出

Homework29 输出一个10行的杨辉三角 ez
#Homework30 本章大作业 7道题

4.面向对象
class Cat{
    String name;
    int age;
}

Cat cat1 = new Cat();

对象分配：在对对象进行分配和引用赋值时，实际上是在对操作对象的引用，额不是对象本身
当p1 = p2时，对于p2 = new Person()，修改p2会使p1同样变化

成员方法：简称方法，人话就是函数
public void function(){
    System.out.print(" ");
}
方法内不能再嵌套定义，会引起麻烦；遵守驼峰命名法
#Homework30 编写类AA，有一个方法是判断这个数是奇数还是偶数，返回boolean;

克隆对象
Homework31:
编写一个方法copyPerson,赋值一个Person对象，返回复制的对象，要求两个对象独立!

递归：算法部分再做做题
#Homework32:一堆递归题 有空来补坑

5.重载 overload
java允许在同一个类中，多个同名方法的存在
参数列表不同即可：即参数类型，参数个数，顺序有一样不同即可；参数名无要求
返回类型无要求 即不同返回类型其余相同不能看成重载
#Homework33 定义三个重载方法，要求①参数不同②功能不同

可变参数 可变参数的实参可以为0个或任意多个；可变参数的实参可以是数组，也本来就是数组；
当可变参数和普通参数放在一起时，要求可变参数放在普通参数的后面；且一个形参列表只能有一个可变参数
Homework34 两个方法，返回姓名和两门课成绩的总分，返回姓名和三门成绩的总分；要求封装成可变参数

6.作用域 skip

7.构造器 constructor
在创建对象的同时赋值，其函数名与对象名相同；构造器没有返回值
#如果编写了一个自定义构造器，这时默认构造器就不会自动生成了 要自己象征性的写一下
即 public Person(){}
#Homework34 在Person类中设置两个构造器，一个带数据生成类，一个默认生成器将姓名设置成位置，年龄设置成18

8. 关键字this
目的是在写构造器时，让形参直接写成属性名，但为了区别时代码易懂而设计的
#Homework35 定义Person类，里面有name，age属性；并提供compareTo比较方法，
用于判断和另外一个人是否年龄相同，如果一样就返回true，不一样就返回false

#Homework36 本章大作业 慈禧几年前写过了不用写了[doge]

9.idea从入门到入坟
快速生成构造器 ctrl加回车
快速运行 ctrl加f5
查看类的继承关系 ctrl加H

idea自定义模版

10. 包 package
快速打包：src文件夹目录下所有class都能找到
包的规则命名：不用数字开头，不使用保留字
idea自动导包 美滋滋qwq 6年前刚开始学的时候还不行

11.访问修饰符规则
public可以访问不同包
protected不能跨包 但是继承子类可以访问
默认类 没有修饰符 继承子类也不行 但是同包可以
private 私有类只能同类中访问

12.封装
把抽象出的数据和对数据的操作方法封装到一起

封装的实现方法：
1.对属性私有化
2.提供公共的set方法，来对属性判断并赋值 可以先定义set方法，再将set写在构造器内
3.提供公共的get方法，来获取属性的值
Homework37 定义两个类AccountTest和Account
Account类要求具有姓名、余额、密码属性 如果不满足则给出提示信息并给默认值
通过setXxx的办法给Account里的属性赋值
在AccountTest中进行测试

13.继承
继承可以让代码被反复利用，提高效率，减少冗余
讲的一坨 直接让gpt来讲
extends与super
如果对子类的构造函数中不写super，编译器会自动加上super，这种情况下，父类的无参构造函数会被调用
如果父类没有无参构造函数且子类没标明构造函数，则直接报错

在子类中直接使用父类的属性也会报错，需要直接用父类的get函数
有问题问gpt super的用法很ok
super和this的调用一定要放在最前面
如果有if 肯定是先定义在前 if后的定义在后 （笑了，原来完全不知道，默认这么写的）

单继承与连续继承；虽然是单继承，但连续继承使得孙子有爷爷的所有属性和方法
单继承：B extends A，此时C不能再extends A, 但C可以extends B；

在 Java 中，当你在子类中定义一个构造函数（无论是有参还是无参构造函数），
如果你没有显式调用 super()，Java 编译器会自动在构造函数的开头插入一个对父类无参构造函数的调用。
这是为了确保父类部分在子类构造函数执行之前被正确初始化。只要没用就一定会加入
具体到这个题为什么没有调用两次super()；首先java内出现这种情况只调用一次super,且出现this("abc")时，
java认为你已经通过另一个构造函数控制了对父类构造函数的调用，因此this("abc")被调用的路径上编译器不会再插入super()

Homework37 P295开始两个案例分析 有点意思
让我想起了五年前学校考c++的题也是这么抽象 各种一路继承的构造函数加输出语句

#Homework38 多次继承的实际使用例题 跟着敲一遍




























